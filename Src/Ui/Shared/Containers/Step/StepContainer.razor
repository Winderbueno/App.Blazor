@inject IJSRuntime JSRuntime

<CascadingValue Value="this">
    <Container FlexColumn=true>
        <section>
            <div class="steps">
                @ChildContent
            </div>
            <aside class="stepper">
                <StepMenu Steps="@steps" />
            </aside>
        </section>
    </Container>
</CascadingValue>

@code {

    [Parameter]
    public RenderFragment? ChildContent { get; set; }

    [Parameter]
    public EventCallback<StepEventArgs> OnNextStepClick { get; set; }

    [Parameter]
    public string Id { get; set; }

    [Parameter]
    public bool DisplayStepNumber { get; set; }

    private List<StepElement> steps = new List<StepElement>();

    public StepElement this[byte index] => steps.SingleOrDefault(x => x.Id == index);

    internal void AddStep(StepElement step)
    {
        steps.Add(step);

        if (step == steps[0])
        {
            step.SetActive();
        }
    }

    public void Refresh()
    {
        Console.WriteLine("refresh");
        StateHasChanged();
    }

    public void Previous(StepElement currentStep)
    {
        currentStep.SetInactive();
        currentStep.IsValidated = false;

        var nextSteps = steps.SkipWhile(x => x != currentStep).ToList();

        foreach (var nextStep in nextSteps)
        {
            nextStep.SetInactive();
        }

        var previousStep = GetPreviousStep(currentStep);
        previousStep.SetActive();

        StateHasChanged();
    }

    public async void Next(StepElement currentStep)
    {
        var stepEventsArgs = new StepEventArgs(currentStep);

        await OnNextStepClick.InvokeAsync(stepEventsArgs);

        DisableNextSteps(currentStep);

        if (currentStep.IsValidated)
        {
            currentStep.IsInvalid = false;
            currentStep.SetInactive();

            var previousSteps = steps.TakeWhile(x => x != currentStep).ToList();

            foreach (var previousStep in previousSteps)
            {
                previousStep.SetInactive();
            }

            var nextStep = GetNextStep(currentStep);
            nextStep.SetActive();

            StateHasChanged();

            await Task.Delay(150);

            await JSRuntime.InvokeVoidAsync("scrollIntoView", $"Step{nextStep.StepNumber}");
        }
        else
        {
            currentStep.IsInvalid = true;
        }
    }

    public void DisableNextSteps(StepElement currentStep)
    {
        currentStep.SetActive();

        var nextSteps = steps.SkipWhile(x => x != currentStep).Skip(1);

        foreach (var step in nextSteps)
        {
            step.SetInactive();
            step.IsValidated = false;
        }

        StateHasChanged();
    }

    internal int FindIndex(StepElement currentStep) => steps.FindIndex(x => x == currentStep);

    internal bool IsFirstStep(StepElement currentStep) => FindIndex(currentStep) == 0;

    internal bool IsLastStep(StepElement currentStep) => FindIndex(currentStep) == steps.Count - 1;

    internal StepElement GetPreviousStep(StepElement currentStep) => steps.TakeWhile(x => x != currentStep).Last();

    internal StepElement GetNextStep(StepElement currentStep) => steps.SkipWhile(x => x != currentStep).Skip(1).First();
}