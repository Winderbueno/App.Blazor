@using System.ComponentModel.DataAnnotations;
@using System.Linq.Expressions;
@using Ui.Shared.Containers.Form.Abstract;
@using Ui.Shared.Containers.Form.Style;

@typeparam TValue
@typeparam TOption
@inherits Field<TValue>

<!-- Lorsque https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/togglePopover sera standardisé : à morderniser -->

<div class="field-wrapper">
    <label>@Label</label>
    @if (Multiple)
    {
        <SelectFieldStyle>
            <div tabindex="0" class="select-wrapper"
             @onfocusin="_ => optionsVisible = true"
             @onfocusout="_ => optionsVisible = false">
                <output class="select-field @(invalid ? "invalid" : "") @(optionsVisible ? "focused" : "")">
                    @if (multipleOptions.Any(x => x.IsChecked == true))
                    {
                        <ul class="select-selected-items">
                            @foreach (var pair in multipleOptions.Where(x => x.IsChecked == true))
                            {
                                <li>
                                    <data value=@pair.Option.Value>@OptionName(pair.Option.Name)</data>
                                    <Icon Id="x" @onclick="() => OnMultipleSelectChange(pair.Option)" />
                                </li>
                            }
                        </ul>
                    }
                    else
                    {
                        <span class="placeholder-color">@Placeholder</span>
                    }
                    <Icon Id=@(optionsVisible ? "chevron-top" : "chevron-bottom") />
                </output>
                <ul class="select-data @(optionsVisible ? "" : "hide")">
                    @foreach (var pair in multipleOptions)
                    {
                        <li @onclick="() => OnMultipleSelectChange(pair.Option)">
                            <input type="checkbox" checked=@pair.IsChecked>
                            <data value=@pair.Option.Value>@OptionName(pair.Option.Name)</data>
                        </li>
                    }
                </ul>
            </div>
        </SelectFieldStyle>
    }
    else
    {
        <InputSelect class="form-control"
                 style="@(Placeholder != null ? "--selected-option-color:" + selectedOptionColor : "")"
                 disabled=@Disabled
                 @oninput=OnInput
                 @onblur=OnBlur
                 DisplayName=@DisplayName
                 Value=Value
                 ValueChanged=ValueChanged
                 ValueExpression=ValueExpression>
            @if (Placeholder != null)
            {
                @*Trick to use null option value as a placeholder*@
                <option value="" selected disabled hidden>@Placeholder</option>
            }
            @if (options != null)
            {
                foreach (var opt in options)
                {
                    <option value="@opt.Value">@OptionName(opt.Name)</option>
                }
            }            
        </InputSelect>
    }

    <ValidationMessage For=ValueExpression></ValidationMessage>
</div>

@code {
    [Parameter]
    public bool Multiple { get; set; } = false;

    /* Validation */
    [Parameter]
    public bool Required { get; set; } = false;
    [Parameter]
    public string RequiredMessage { get; set; } = "Field is required.";

    /* Options */
    [EditorRequired, Parameter]
    public IEnumerable<TOption>? Options { get; set; }
    [Parameter]
    public (Func<TOption?, string?>? Name, Func<TOption?, string?>? Value)? OptionGetters { get; set; }


    private IEnumerable<Option>? options;
    private bool optionsVisible = false, invalid = false;
    private ValidationMessageStore? store;
    private List<(Option Option, bool IsChecked)> multipleOptions = new();

    private string selectedOptionColor => Value == null ? "var(--k-color-grey)" : "var(--k-color-primary);";

    protected override void OnInitialized()
    {
        options = Options!.ToOption(OptionGetters?.Name, OptionGetters?.Value);
        if (Required) EditContext!.OnValidationRequested += OnValidationRequested;
        EditContext!.OnFieldChanged += OnFieldChanged;
        store = new(EditContext);
        ResetCheckBox();
    }

    protected override void OnParametersSet()
    {
        if (Multiple) ValueExpression = (() => Value);
        if (Value == null) ResetCheckBox();
    }

    private async void OnMultipleSelectChange(Option option)
    {
        multipleOptions = multipleOptions
            .Select(x => x.Option.Value != option.Value ? x : new(x.Option, !x.IsChecked))
            .ToList();

        var values = multipleOptions.Where(x => x.IsChecked == true).Select(x => x.Option.Value).ToList();
        await ValueChanged.InvokeAsync((TValue)(object)values);

        EditContext!.NotifyFieldChanged(EditContext.Field(ParseFieldName()));

        OnFieldChanged();
    }

    private string? OptionName(string? name)
        => t[name].Contains("##") ? name : t[name];

    private void OnFieldChanged(object? sender = null, FieldChangedEventArgs? e = null)
    {
        store?.Clear();
        invalid = false;
    }

    private void OnValidationRequested(object? sender = null, ValidationRequestedEventArgs? e = null)
    {
        store?.Clear();

        string? errorMessage = Multiple switch
        {
            false => Value == null ? RequiredMessage : null,
            true => multipleOptions.All(x => x.IsChecked == false) ? RequiredMessage : null,
        };

        invalid = Multiple && errorMessage != null;

        if (errorMessage != null)
            store?.Add(() => Value!, errorMessage);
    }

    private void ResetCheckBox()
    {
        if (Multiple && options != null) multipleOptions = options.Select(x => (x, false)).ToList();
    }
}